**数据结构二**

> **Trie树** 
>
> 快速存储字符串集合
>
> ```c++
> int son[N][26], cnt[N], idx;
> // 0号点既是根节点，又是空节点
> // son[][]存储树中每个节点的子节点
> // cnt[]存储以每个节点结尾的单词数量
> 
> // 插入一个字符串
> void insert(char *str)
> {
>     int p = 0;
>     for (int i = 0; str[i]; i ++ )
>     {
>         int u = str[i] - 'a';
>         if (!son[p][u]) son[p][u] = ++ idx;
>         p = son[p][u];
>     }
>     cnt[p] ++ ;
> }
> 
> // 查询字符串出现的次数
> int query(char *str)
> {
>     int p = 0;
>     for (int i = 0; str[i]; i ++ )
>     {
>         int u = str[i] - 'a';
>         if (!son[p][u]) return 0;
>         p = son[p][u];
>     }
>     return cnt[p];
> }
> ```
>
> ```go
> package main
> 
> import "fmt"
> 
> var son [][]int
> var cnt []int
> const N = 100010
> //idx 用于标记节点在树（数组）中的位置
> //从数组化链表角度看问题
> var idx = 0
> 
> func main() {
>     //初始化
>     cnt = make([]int, N)
>     son = make([][]int, N)
>     for i := 0; i < N; i++ {
>         son[i] = make([]int, 26)
>     }
>     
>     //读入参数
>     var m int
>     var op, str string
>     fmt.Scanf("%d", &m)
>     for ; m > 0; m-- {
>         fmt.Scanf("%s%s", &op, &str)
>         switch op {
>             case "I": insert(str)
>             case "Q": fmt.Printf("%d\n", query(str))
>         }
>     }
> }
> 
> func insert(str string) {
>     floor := 0
>     for i := 0; i < len(str); i++ {
>         pos := str[i] - 'a'
>         if son[floor][pos] == 0 {
>             idx += 1
>             son[floor][pos] = idx
>         }
>         floor = son[floor][pos]
>     }
>     cnt[floor] += 1
> }
> 
> func query(str string) int {
>     floor := 0
>     for i := 0; i < len(str); i++ {
>         pos := str[i] - 'a'
>         if son[floor][pos] == 0 {
>             return 0
>         }
>         floor = son[floor][pos]
>     }
>     return cnt[floor]
> }
> ```
>
> 
>
> **并查集**
>
> ```c++
> //并查集
> //在近乎O(1)的复杂度下
> //1.将两个集合合并
> //2.询问两个元素是否在一个集合当中
> //基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点， p[x]表示x的父节点
> 
> //问题一：如何判断树根：if (p[x] == x)
> //问题二：如何求x的集合编号: while(p[x] != x) x = p[x]
> //问题三：如何合并两个集合: p[x] 是x的集合编号， p[y] 是y的集合编号。p[x] = y
> //优化: 路径压缩 ==> 将所有节点的父节点指针指向集合编号！
> 
> (1)朴素并查集：
> 
>     int p[N]; //存储每个点的祖宗节点
> 
>     // 返回x的祖宗节点
>     int find(int x)
>     {
>         if (p[x] != x) p[x] = find(p[x]);
>         return p[x];
>     }
> 
>     // 初始化，假定节点编号是1~n
>     for (int i = 1; i <= n; i ++ ) p[i] = i;
> 
>     // 合并a和b所在的两个集合：
>     p[find(a)] = find(b);
> 
> (2)维护size的并查集：
> 
>     int p[N], size[N];
>     //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量
> 
>     // 返回x的祖宗节点
>     int find(int x)
>     {
>         if (p[x] != x) p[x] = find(p[x]);
>         return p[x];
>     }
> 
>     // 初始化，假定节点编号是1~n
>     for (int i = 1; i <= n; i ++ )
>     {
>         p[i] = i;
>         size[i] = 1;
>     }
> 
>     // 合并a和b所在的两个集合：
>     size[find(b)] += size[find(a)];
>     p[find(a)] = find(b);
> 
> 
> (3)维护到祖宗节点距离的并查集：
> 
>     int p[N], d[N];
>     //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
> 
>     // 返回x的祖宗节点
>     int find(int x)
>     {
>         if (p[x] != x)
>         {
>             int u = find(p[x]);
>             d[x] += d[p[x]];
>             p[x] = u;
>         }
>         return p[x];
>     }
> 
>     // 初始化，假定节点编号是1~n
>     for (int i = 1; i <= n; i ++ )
>     {
>         p[i] = i;
>         d[i] = 0;
>     }
> 
>     // 合并a和b所在的两个集合：
>     p[find(a)] = find(b);
>     d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
> 
> ```
>
> ```go
> //朴素并查集
> package main
> 
> import "fmt"
> 
> var p []int
> var res []string
> const N = 100010
> 
> func main () {
>     p = make([]int, N)
>     res = make([]string, 0)
>     var m, n, i, j int
>     var op string
>     fmt.Scanf("%d%d", &n, &m)
>     for i := 1; i <= n; i ++ {
>         p[i] = i
>     }
>     for ; m > 0; m-- {
>         fmt.Scanf("%s%d%d", &op, &i, &j)
>         if op == "M" {
>             p[find(i)] = find(j)
>         } else {
>             if find(i) == find(j) {
>                 res = append(res, "Yes")
>             } else {
>                 res = append(res, "No")
>             }
>         }
>     }
>     
>     for i := 0; i < len(res); i++ {
>         fmt.Println(res[i])
>     } 
> }
> 
> func find(i int) int {
>     if p[i] != i {
>         p[i] = find(p[i])
>     }
>     return p[i]
> }
> 
> //维护Size的并查集
> package main
> 
> import (
>     "fmt"
>     "strconv"
> )
> 
> var p, size []int
> var res []string
> const N = 100010
> 
> func main () {
>     p = make([]int, N)
>     size = make([]int, N)
>     res = make([]string, 0)
>     var m, n, i, j int
>     var op string
>     fmt.Scanf("%d%d", &n, &m)
>     for i := 1; i <= n; i ++ {
>         p[i] = i
>         size[i] = 1
>     }
>     for ; m > 0; m-- {
>         fmt.Scanf("%s", &op)
>         if op == "C" {
>             fmt.Scanf("%d%d", &i, &j)
>             if p[find(i)] == p[find(j)] {continue}
>             size[find(j)] += size[find(i)]
>             p[find(i)] = find(j)
>         } else if op == "Q1" {
>             fmt.Scanf("%d%d", &i, &j)
>             if find(i) == find(j) {
>                 res = append(res, "Yes")
>             } else {
>                 res = append(res, "No")
>             }
>         } else if op == "Q2" {
>             fmt.Scanf("%d", &i)
>             num := strconv.Itoa(size[find(i)])
>             res = append(res, num)
>         }
>     }
>     
>     for i := 0; i < len(res); i++ {
>         fmt.Println(res[i])
>     } 
> }
> 
> func find(i int) int {
>     if p[i] != i {
>         p[i] = find(p[i])
>     }
>     return p[i]
> }
> 
> 
> ```
>
> **堆**
>
> ```c++
> //如何手写一个堆？
> //1.插入一个数           heap[++size] = x; up(size)
> //2.求集合当中的最小值    heap[1]			
> //3.删除最小值           heap[1] = heap[size]; size --; down(1)
> //4.删除任意一个元素	 heap[k] = heap[size]; size --; down(k); up(k); 		
> //5.修改任意一个元素	 heap[k] = x; down(k); up(k); 
> 
> // h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
> // ph[k]存储第k个插入的点在堆中的位置
> // hp[k]存储堆中下标是k的点是第几个插入的
> int h[N], ph[N], hp[N], size;
> 
> // 交换两个点，及其映射关系
> void heap_swap(int a, int b)
> {
>     swap(ph[hp[a]],ph[hp[b]]);
>     swap(hp[a], hp[b]);
>     swap(h[a], h[b]);
> }
> 
> void down(int u)
> {
>     int t = u;
>     if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
>     if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
>     if (u != t)
>     {
>         heap_swap(u, t);
>         down(t);
>     }
> }
> 
> void up(int u)
> {
>     while (u / 2 && h[u] < h[u / 2])
>     {
>         heap_swap(u, u / 2);
>         u >>= 1;
>     }
> }
> 
> // O(n)建堆
> for (int i = n / 2; i; i -- ) down(i);
> ```
>
> ```go
> //一般堆操作
> package main
> 
> import "fmt"
> 
> var size  int
> var heap []int
> const N = 100010
> 
> func main() {
>     //size = 0
>     heap = make([]int, N)
>     m, n := 0, 0
>     fmt.Scanf("%d%d", &n, &m)
>     for i := 1; i <= n; i++ {
>         fmt.Scanf("%d", &heap[i])
>         
>     }
>     //建堆
>     size = n
>     //fmt.Println(heap[:size])
>     for i := n/2; i > 0; i-- {
>         down(i)
>     }
>     //fmt.Println(heap[:size])
>     
>     for ; m > 0; m-- {
>         //fmt.Println(heap[:size])
>         fmt.Printf("%d ", heap[1])
>         //fmt.Println(heap[:size])
>         heap[1] = heap[size]
>         size -= 1
>         down(1)
>     }
> }
> 
> func down(f int) {
>     s := f
>     if  2*f <= size && heap[2*f] < heap[s] {
>         s = 2*f
>     }
>     if  2*f+1 <= size && heap[2*f+1] < heap[s] {
>         s = 2*f+1
>     }
>     if s != f {
>         heap[s], heap[f] = heap[f], heap[s]
>         down(s)
>     }
> }
> 
> func up(s int) {
>     for s/2 > 0 && heap[s/2] > heap[s] {
>         heap[s/2], heap[s] = heap[s], heap[s/2]
>         s /= 2
>     }
> }
> 
> //复杂堆操作
> package main
> 
> import "fmt"
> 
> var size  int
> var heap, ph, hp []int
> const N = 100010
> 
> func main() {
>     size = 0
>     heap = make([]int, N)
>     hp = make([]int, N)
>     ph = make([]int, N)
>     time := 0
>     
>     var m int 
>     var op string
>     var op1, op2 int
>     fmt.Scanf("%d", &m)
>     for ; m > 0; m-- {
>         fmt.Scanf("%s", &op)
>         switch (op) {
>             case "I":
>                 fmt.Scanf("%d", &op1)
>                 size += 1
>                 time += 1
>                 heap[size] = op1
>                 ph[time] = size
>                 hp[size] = time
>                 up(size)
>             case "PM":
>                 fmt.Println(heap[1])
>             case "DM":
>                 heapSwap(1, size)
>                 size -= 1
>                 down(1)
>             case "D":
>                 fmt.Scanf("%d", &op1)
>                 pos := ph[op1]
>                 heapSwap(pos, size)
>                 size -= 1
>                 down(pos)
>                 up(pos)
>             case "C":
>                 fmt.Scanf("%d%d", &op1, &op2)
>                 pos := ph[op1]
>                 heap[pos] = op2
>                 down(pos)
>                 up(pos)
>         }
>     }
> }
> 
> func down(f int) {
>     s := f
>     if  2*f <= size && heap[2*f] < heap[s] {
>         s = 2*f
>     }
>     if  2*f+1 <= size && heap[2*f+1] < heap[s] {
>         s = 2*f+1
>     }
>     if s != f {
>         heapSwap(s, f)
>         down(s)
>     }
> }
> 
> func up(s int) {
>     for s/2 > 0 && heap[s/2] > heap[s] {
>         heapSwap(s, s/2)
>         s /= 2
>     }
> }
> 
> func heapSwap(i, j int) {
>     ph[hp[i]], ph[hp[j]] = ph[hp[j]], ph[hp[i]]
>     hp[i], hp[j] = hp[j], hp[i]
>     heap[i], heap[j] = heap[j], heap[i]
> }
> ```
>
> 