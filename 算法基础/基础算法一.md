**基础算法一**

------------------------------------------

**一、快速排序（分治）**

1. 确定分界点  q[l] , q[(l+r)/2], q[r] 随机
2. 调整区间  分界点左侧 <= x 分界点右侧 >= x （x不一定为分界点）
3. 递归处理左右两侧

简要做法：

> 左右两侧指针i， j不断向中心移动。保证i左侧小于分界点值， j右侧大于分界点值，否则中止移动指针。将停下来的i j指针进行swap。直接左右两指针相遇或穿越。
>
> 递归处理左右两侧。

模板总结：

```scala
object main {
  def main(args: Array[String]): Unit = {
    val arr = Array[Int](3,2,3,5,4)
    quickSort(arr, 0, arr.length-1)
    println(arr.mkString)
  }

  def quickSort(nums: Array[Int], left: Int, right: Int): Unit = {
    //判断边界
    if (left >= right) return

    val x = nums(left)
    //这里对i j指针各左右移动一次，防止某次循环中遇到相同值从而导致死循环
    var i = left-1
    var j = right+1


    while (i < j) {
      i += 1
      while (nums(i) < x) {
        i += 1
      }

      j -= 1
      while (nums(j) > x) {
        j -= 1
      }

      if (i < j) {
        val temp = nums(j)
        nums(j) = nums(i)
        nums(i) = temp
      }
    }

    quickSort(nums, left, j)
    quickSort(nums, j+1, right)
  }
}
```

```go
package main

import "fmt"

func main() {
	arr := []int{5,2,1,3,4}
	quickSort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}

func quickSort(nums []int, left, right int) {
	if left >= right {
		return
	}

	x, i, j := nums[left], left-1, right+1

	for i < j {

		i += 1
		for nums[i] < x {
			i += 1
		}

		j -= 1
		for nums[j] > x {
			j -= 1
		}

		if i < j {
			temp := nums[j]
			nums[j] = nums[i]
			nums[i] = temp
		}
	}
	quickSort(nums, left, j)
	quickSort(nums, j+1, right)
}


```

