go sort.Sort的实现 源码总结

```go
//https://github.com/Junedayday/code_reading/blob/master/sort/sort.go
//1. 实现 Len， Less， Swap方法
//2. 根据长度及maxDepth判断使用排序方法，设置阈值
fun maxDepth(n int) int {
    var depth int
    for i := n; i > 0; i >>= 1 {
        depth++
    } 
    return depth * 2
}
//防止pivot选择问题，快排复杂度升高，这种情况下转而使用堆排序
//3.判断元素是否多于12个
//3.1 当小于12个时，从a（左端）+6 至 b 将对应位置上较小的数放入前6个位置（gap为6的shell排序），而后进行插入排序

//3.2 如果在maxDepth次数内快排仍未完成，改使用堆排序处理
//3.3 使用doPivot函数获取mlo， mhi
//对数据较小的一侧进行递归，规模较大的一侧继续循环
//为什么不适用两个递归？
//1.减少递归， 减少一次压栈、出栈操作
//2.数据规模较小一侧，更易快速完成，释放空间
if mlo - a < b - mhi {
    quickSort(data, a, mlo, maxDepth)
    a = mhi
} else {
    quickSort(data, mhi, b, maxDepth)
    b = mlo
}

//4.堆排序
//堆是一个特殊的完全二叉树，并且；设有一个堆顶编号为1的含有 n 个元素的堆，总是有以下的几点特性：
//第i个分支节点的子节点的序号总是2*i + 1和 2 * i + 2，
//父节点总是不大于或者不小于自己的子节点，父节点总是不小于子节点的堆是一个大顶堆，反之则为一个小顶堆
//这个堆的最深深度为 (log2n) + 1，所以第 i 个节点所在的层数也为 (log2n) + 1
//堆里的第i层最多有 2^i - 1个节点
//堆化(向下调整)  前提是 只有一个地方不满足堆的性质，其他位置都满足堆的性质
//找出孩子结点中值最大的结点下标,比较该根结点与最大的孩子结点的大小，如果孩子结点大，则换位置
//此处使用softDown函数进行堆化， 形成大堆
//整个堆排序分为两步：
//堆排序第一步： （hi-1）/2 到 0的元素进行向下堆化 （结合第二步，降低整体堆调整次数）
//堆排序第二步： 将上一次排序后最大的值放到最后（减低该值堆化代价），重新向下堆化

//5.dopovit函数
//元素大于40， 进行三次三值取中 (而后又进行一次， 相当于9值取中)
//medianOfThree
//povit 设置三值取中中间位置
```

