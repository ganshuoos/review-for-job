函数调用栈

>**函数调用 宏观**
>
>>1. 函数被编译器编译为一堆机器指令，写入可执行文件
>>2. 执行时，机器指令对应虚拟空间中代码段（栈、堆、数据段、代码段）
>>3. 若一个函数中调用另一个函数，编译器会对应生成一条call指令，执行call指令时跳转到被调用函数入口处开始执行。
>>4. 每个函数最后都有一条ret指令，负责在函数结束后条回到调用处。
>
>**栈 （虚拟空间）**
>
>> 存储局部变量、参数、返回值等。
>>
>> ![](.assets/%E6%A0%88%E7%BB%93%E6%9E%84.PNG)‘
>>
>> 单个函数栈结构如图依次为（由高到低）：
>>
>> 1. 调用者栈基地址
>> 2. 局部变量
>> 3. 返回值
>> 4. 参数
>> 5. 返回地址（call 产生）
>>
>> call指令只做两件事：返回地址入栈， 跳转到被调用者的栈基地址。
>>
>> **go栈帧分配**
>>
>> go的函数栈帧并不是逐步扩张的，而是一次性分配，直接将栈顶指针移动到所需最大栈空间的位置。然后通过栈顶指针与偏移量结合的相对寻址方式处理。
>>
>> ![](.assets/%E6%A0%88%E5%88%86%E9%85%8D.PNG)
>>
>> 一次性分配为了避免栈访问越界，由于函数栈帧大小可以在编译时确定， 对于栈消耗较大的函数，编译器会在函数头部插入检测代码， 若发现需要栈增长， 就会另外分配一段足够大的栈空间，并把原来栈上的数据拷过来，原栈空间释放。
>>
>> ![](.assets/%E6%A0%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.PNG)
>>
>>  
>>
>> **值拷贝与引用拷贝**
>>
>> 函数入参数据 自右向左
>>
>> ![](.assets/%E5%80%BC%E6%8B%B7%E8%B4%9D.PNG)
>>
>> ![](.assets/%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D.PNG)
>>
>> **返回值**
>>
>> 由于Go语言支持多返回值， 栈上分配返回值空间更合适。
>>
>> **defer 与 return**（赋值 defer ret）
>>
>> 匿名返回值情况
>>
>> ![](.assets/defer%E4%B8%8Ereturn.PNG)
>>
>> 命名返回值情况
>>
>> ![](.assets/defer%E4%B8%8Ereturn%20%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E.PNG)
>>
>> 